我们要在GRDB， documentDirectory/mori.db 中存储ChartItem and ChartCollection，注意是数据层的，视图层的数据ChartItem是不是得换一个名字？
ChartItem: 

1. id: uuid string
2. Title: string
3. Type: string, contribution, bar, progress
4. colorTheme: string
5. Settings: ChartItemSetting json string
6. belongCollectionId: string
7. Order: number
8. executionType: string like sql
9. executionStatement: string
10. Pinned: boolean
11. creationDate: Datetime
12. lastModifiedDate: Datetime

ChartItemSetting Model:

1. if type is contribution
   1. dateRangeType: 
      1. over the past year
      2. this month
      3. this year
      4. last year
      5. Custom month
      6. Custom year
   2. dateRangeCustom: 2025-05-01T00:00:00+08:00 - 2025-05-30T23:59:59+08:00
2. if type is progress
   1. Goat: int number
   2. dateRangeType: 
      1. today
      2. this week
      3. this month
      4. This year
      5. Custom
   3. dateRangeCustom: 2025-05-01T00:00:00+08:00 - 2025-05-30T23:59:59+08:00

Chart Collection

1. id: uuid string
2. Title: string
3. Order: number
4. creationDate: Datetime
5. lastModifiedDate: Datetime

---

ChartItemSetting的处理方式参照

### 示例

假设你有如下结构：

```
swift


CopyEdit
struct Settings: Codable, Equatable {
    var darkModeEnabled: Bool
    var notificationFrequency: String
}

struct User: Codable, FetchableRecord, PersistableRecord {
    var id: Int64
    var name: String
    var settings: Settings
}
```

### 让 `Settings` 支持 GRDB 存储

你需要扩展 `Settings` 让它实现 `DatabaseValueConvertible`：

```
swift


CopyEdit
import GRDB

extension Settings: DatabaseValueConvertible {
    public var databaseValue: DatabaseValue {
        try! JSONEncoder().encode(self).databaseValue
    }

    public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Settings? {
        guard let data = Data.fromDatabaseValue(dbValue) else { return nil }
        return try? JSONDecoder().decode(Settings.self, from: data)
    }
}
```

这样 GRDB 就能将 `settings` 自动序列化为字符串存储，并在读取时自动还原为 `Settings` 对象。